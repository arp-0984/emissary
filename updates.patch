diff --git a/src/main/java/emissary/util/FlexibleDateTimeParser.java b/src/main/java/emissary/util/FlexibleDateTimeParser.java
index 73834a9..61aeeca 100644
--- a/src/main/java/emissary/util/FlexibleDateTimeParser.java
+++ b/src/main/java/emissary/util/FlexibleDateTimeParser.java
@@ -24,6 +24,7 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
+import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 
@@ -58,9 +59,11 @@ public final class FlexibleDateTimeParser {
      * beginning or end
      */
     private static final Pattern REMOVE = Pattern.compile("<.+?>$|=0D$|\\(|\\)|\"|\\[|]|\\W+$|^\\W+", Pattern.DOTALL);
-
-    private static final Pattern PHT_REPLACE = Pattern.compile("PHT");
-    private static final String PT_TIMEZONE = "PT";
+    /*
+     * This is our last ditch parsing effort if we failed to parse the string - remove all extra text after the numeric time
+     * zone offset
+     */
+    private static final Pattern EXTRA_TEXT_REMOVE = Pattern.compile("(\\+\\d{4}).*$");
 
     /* timezone - config var: TIMEZONE */
     private static ZoneId timezone = ZoneId.of(DEFAULT_TIMEZONE);
@@ -68,7 +71,7 @@ public final class FlexibleDateTimeParser {
     /* date time formats - vars: FORMAT_DATETIME_MAIN */
     private static List<DateTimeFormatter> dateFormatsMain = new ArrayList<>();
 
-    /* Extra date time formats - lits to try if our main list has failed - vars: FORMAT_DATETIME_EXTRA */
+    /* Extra date time formats - list to try if our main list has failed - vars: FORMAT_DATETIME_EXTRA */
     private static List<DateTimeFormatter> dateFormatsExtra = new ArrayList<>();
 
     /* init */
@@ -99,14 +102,61 @@ public final class FlexibleDateTimeParser {
      * Attempts to parse a string date using pre-configured patterns
      *
      * @param dateString the string to parse
-     * @param tryExtensiveFormatList True if we want to try out complete list of date/time formats False if we only want to
+     * @param tryExtensiveParsing True if we want to try out complete list of date/time formats False if we only want to
      *        attempt the most common date/time formats
      * @return the parsed immutable and thread-safe zoned-date, or null if it failed to parse
      */
-    public static ZonedDateTime parse(final String dateString, boolean tryExtensiveFormatList) {
+    public static ZonedDateTime parse(final String dateString, boolean tryExtensiveParsing) {
+        ZonedDateTime zdt = parsingHelper(dateString, tryExtensiveParsing);
+
+        if (zdt != null || !tryExtensiveParsing) {
+            return zdt;
+        } else {
+            // if that all failed and we want to attempt extensive parsing, attempt the last ditch efforts we can try
+            return lastDitchParsingEffort(dateString);
+        }
+    }
+
+    /**
+     * If all our formats failed to parse a date string, give it one last try to parse it. Look for a numeric offset (e.g.
+     * +0000) and remove all text afterwards. This should cover another set of cases where there is random text appended to
+     * the end of the string, as well as removing invalid non-numeric time zone offsets while still picking up the numeric
+     * offset Assumption - that tryExtensiveParsing is true - we should only get to this point if we want to try our best to
+     * parse
+     * 
+     * @param date The date string to parse
+     * @return the ZonedDateTime object if removing text at the end was successful, or null otherwise
+     */
+    static ZonedDateTime lastDitchParsingEffort(final String date) {
+
+        // Attempt to remove all text after the numeric offset and try again - this should give us a valid date string
+        // to work with
+        Matcher matcher = EXTRA_TEXT_REMOVE.matcher(date);
+        if (matcher.find()) {
+            String secondChanceDate = matcher.replaceAll(matcher.group(1));
+            // if we removed text, attempt to parse again to see if we are more successful this time
+            return parsingHelper(secondChanceDate, true);
+        }
+        return null;
+    }
+
+    /**
+     * Created to help against code duplication. Calls parse with the standard set of date formats, and then if
+     * that fails, attempt the extra set of date formats if tryExtensiveParsing is set to true.
+     * 
+     * @param dateString The string we are attempting to parse
+     * @param tryExtensiveParsing Whether or not to use the extensive set of date formats
+     * @return The ZonedDateTime object if our parsing was successful, or null if not
+     */
+    private static ZonedDateTime parsingHelper(final String dateString, boolean tryExtensiveParsing) {
         ZonedDateTime zdt = parse(dateString, dateFormatsMain);
 
-        return zdt == null && tryExtensiveFormatList ? parse(dateString, dateFormatsExtra) : zdt;
+        // if we got a successful parse or we don't want to attempt "extensive parsing", return here
+        if (!tryExtensiveParsing || zdt != null) {
+            return zdt;
+        }
+        zdt = parse(dateString, dateFormatsExtra);
+        return zdt;
     }
 
     /**
@@ -269,12 +319,6 @@ public final class FlexibleDateTimeParser {
         cleanedDateString = REPLACE.matcher(cleanedDateString).replaceAll(SPACE);
         cleanedDateString = REMOVE.matcher(cleanedDateString).replaceAll(EMPTY);
 
-        // PHT does not appear to be a valid time zone in java, but is included in the IANA timezone list. If PHT is in
-        // a date string, we get an exception. This was the only information I could find about this issue online -
-        // it suggests "PT" is the valid Philippines time zone in java:
-        // https://stackoverflow.com/questions/70605148/why-is-the-short-display-name-for-asia-manila-timezone-pt-in-java
-        cleanedDateString = PHT_REPLACE.matcher(cleanedDateString).replaceAll(PT_TIMEZONE);
-
         return StringUtils.trimToNull(cleanedDateString);
     }
 
diff --git a/src/test/java/emissary/util/FlexibleDateTimeParserTest.java b/src/test/java/emissary/util/FlexibleDateTimeParserTest.java
index 032261f..5383433 100644
--- a/src/test/java/emissary/util/FlexibleDateTimeParserTest.java
+++ b/src/test/java/emissary/util/FlexibleDateTimeParserTest.java
@@ -50,13 +50,13 @@ class FlexibleDateTimeParserTest extends UnitTest {
     }
 
     /**
-     * Test parsing date strings and include the extra/ more comprehensive patterns in the config file
+     * Test parsing date strings with tryExtensiveParsing set to true
      *
      * @param date the string representation of a date
      * @param expected the expected parsed and formatted date
      * @param msg the error message to display if the test fails
      */
-    private static void extraPatternTest(@Nullable String date, long expected, String msg) {
+    private static void testExtensiveParsing(@Nullable String date, long expected, String msg) {
         ZonedDateTime unknownParse = FlexibleDateTimeParser.parse(date, true);
         Assertions.assertEquals(expected, unknownParse == null ? 0L : unknownParse.toEpochSecond(), "Error on: " + msg);
     }
@@ -82,7 +82,7 @@ class FlexibleDateTimeParserTest extends UnitTest {
 
         for (String offset : offsets) {
             String dateAndOffset = dateString + " " + offset;
-            extraPatternTest(dateAndOffset, expected, "Did not parse this string correctly: " + dateAndOffset);
+            testExtensiveParsing(dateAndOffset, expected, "Did not parse this string correctly: " + dateAndOffset);
         }
     }
 
@@ -176,7 +176,6 @@ class FlexibleDateTimeParserTest extends UnitTest {
         test("Tue, 5 Jan 2016 02:20:30 +0800 AWST", EXPECTED_FULL, pattern);
         test("Tue, 5 Jan 2016 02:20:30 +0800 CST", EXPECTED_FULL, pattern);
         test("Tue, 5 Jan 2016 02:20:30 +0800 HKT", EXPECTED_FULL, pattern);
-        test("Tue, 5 Jan 2016 02:20:30 +0800 PHT", EXPECTED_FULL, pattern);
         test("Tue, 5 Jan 2016 02:20:30 +0800 PT", EXPECTED_FULL, pattern);
         test("Tue, 5 Jan 2016 02:20:30 +0800 WITA", EXPECTED_FULL, pattern);
         test("Tue, 5 Jan 2016 03:20:30 +0900 JST", EXPECTED_FULL, pattern);
@@ -238,14 +237,14 @@ class FlexibleDateTimeParserTest extends UnitTest {
 
     @Test
     void parse_yyyyMMddTHHmmssSSSX_Extra() {
-        extraPatternTest("2016-01-04T18:20:30", EXPECTED_FULL, "0 digits for fraction of a second");
-        extraPatternTest("2016-01-04T18:20:30.0", EXPECTED_FULL, "1 digit for fraction of a second");
-        extraPatternTest("2016-01-04T18:20:30.00", EXPECTED_FULL, "2 digits for fraction of a second");
-        extraPatternTest("2016-01-04T18:20:30.0000", EXPECTED_FULL, "4 digits for fraction of a second");
-        extraPatternTest("2016-01-04T18:20:30.00000", EXPECTED_FULL, "5 digits for fraction of a second");
-        extraPatternTest("2016-01-04T18:20:30.000000", EXPECTED_FULL, "6 digits for fraction of a second");
-        extraPatternTest("2016-01-04T18:20:30.0000000", EXPECTED_FULL, "7 digits for fraction of a second");
-        extraPatternTest("2016-01-04T18:20:30.00000000", EXPECTED_FULL, "8 digits for fraction of a second");
+        testExtensiveParsing("2016-01-04T18:20:30", EXPECTED_FULL, "0 digits for fraction of a second");
+        testExtensiveParsing("2016-01-04T18:20:30.0", EXPECTED_FULL, "1 digit for fraction of a second");
+        testExtensiveParsing("2016-01-04T18:20:30.00", EXPECTED_FULL, "2 digits for fraction of a second");
+        testExtensiveParsing("2016-01-04T18:20:30.0000", EXPECTED_FULL, "4 digits for fraction of a second");
+        testExtensiveParsing("2016-01-04T18:20:30.00000", EXPECTED_FULL, "5 digits for fraction of a second");
+        testExtensiveParsing("2016-01-04T18:20:30.000000", EXPECTED_FULL, "6 digits for fraction of a second");
+        testExtensiveParsing("2016-01-04T18:20:30.0000000", EXPECTED_FULL, "7 digits for fraction of a second");
+        testExtensiveParsing("2016-01-04T18:20:30.00000000", EXPECTED_FULL, "8 digits for fraction of a second");
     }
 
     @Test
@@ -668,6 +667,19 @@ class FlexibleDateTimeParserTest extends UnitTest {
     }
 
     @Test
+    void testLastDitchEffortParsing() {
+        testExtensiveParsing("Jan 04 2016 18:20:30 +0000.5555555", EXPECTED_FULL, "Removing text at the end should be successful");
+        testExtensiveParsing("Jan 04 2016 18:20:30 +0000 (This is not a date offset)", EXPECTED_FULL,
+                "Removing text at the end should be successful");
+        testExtensiveParsing("Tue, 5 Jan 2016 02:20:30 +0800 PHT", EXPECTED_FULL,
+                "PHT is a timezone not parsed by DateTimeFormatter, but we should still parse correctly with the numeric time zone offset.");
+
+        // we should not attempt to remove random text at the end when we are not specifying tryExtensiveFormatList to be true
+        test("Jan 04 2016 18:20:30 +0000.5555555", 0L, "Fail to parse when tryExtensiveFormatList is false");
+        test("Jan 04 2016 18:20:30 +0000 (This is not a date offset)", 0L, "Fail to parse when tryExtensiveFormatList is false");
+    }
+
+    @Test
     void testBad() {
         test("", 0L, "EMPTY");
         test(null, 0L, "NULL");
